Model SysADLModel ; 
package SysADL.types { 
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { }
} 
Requirement motorTempSensorFR ( 1.3 ) { 
	text = "O sensor deve monitorar continuamente a temperatura e detectar quando excede 100 graus celsius"
derive sensorPerformanceNFR ; } 
Requirement motorControlFR ( 1 ) { 
	text = "Capacidade de Ligar e Desligar o Motor"
} Requirement fuelSensorFR ( 1.2.1 ) { 
	text = "Monitora a quantidade de combustivel e detecta se está abaixo de 2 litros"
derive sensorPerformanceNFR ; } 
Requirement baterySensorFR ( 2.1 ) { 
	text = "Acompanha a carga da bateria e identifica quando está abaixo de 20%" 
	derive  sensorPerformanceNFR ; } 
Requirement statusDisplayFR ( 2 ) { 
	text = "Avisa visualmente o motorista o estado do sistema e exibe alertas visuais"
} 
Requirement engineActivationDeviceFR ( 1.1 ) { 
	text = "Dispositivo acionado pelo usuário para ligar o motor" 
} 
 
Requirement AutoTurnOffFR ( 1.2 ) { 
	text = "Desligar o motor se uma das condições energenciais do sensor de temperatura ou combustivel forem satisfeitas por 2 minutos continuos"
} 
Requirement beepAlarmFR ( 3 ) { text = "Faz um barulho para alertar o usuário" } 
Requirement sensorPerformanceNFR ( 3.0 ) { 
	text = "Os sensores devem ter uma resposta atualização de estado de no máximo 2 segundos"
} 
Requirement alarmPerformanceNFT ( 3.1 ) { 
	text = "O sistema deve responder com o alarme no máximo em 0.1 segundos após detectar condições críticas" 
	derive beepAlarmFR , statusDisplayFR ;
} 
Requirement compatibilityNFR ( 3.2 ) { 
	text = "O sistema deve ser capaz de ser conectado em diferentes veículos independente do fabricante."
} 
Requirement upgradabilityNFR ( 3.3 ) { 
	text = "O sistema deve ser suportar updates de firmware para possíveis correções no software em casos de necessidade."
} 
Requirement failureDetectionNFT ( 3.4 ) { 
	text = "O sistema deve detectar caso algum sensor ou componente esteja apresentando falhas. E exibir elas ao usuário no status display." 
	derive statusDisplayFR ;
} 
Requirement securityNFR ( 3.5 ) { 
	text = "O sistema deve bloquear acessos indevidos ao sistema e modificações nos componentes dele. Toda a comunicação de não críticos (não provenientes diretamente do sensor) deve ser criptografada."
	derive engineActivationDeviceFR,motorControlFR
; } 
package dataTypes { 
	import SysADL.types ; 
	value type celciusTemp extends SysADL.types.Real { } 
	value type liters extends SysADL.types.Real { } 
	value type percent extends SysADL.types.Real { } 
	value type criticalAlert extends SysADL.types.Boolean { } 
	value type noSignalAlert extends SysADL.types.Boolean { } 
	dimension encryptedData 
	value type onOffSecure  extends SysADL.types.Boolean { dimension = encryptedData }  
	value type byteStream { dimension = encryptedData }  
	} 
	
package scPorts { 
	import SysADL.types ; 
	import dataTypes ; 
	port def mortorTempOPT { flow out celciusTemp } 
	port def fuelLitersOPT { flow out liters } 
	port def bateryLevelOPT { flow in percent } 
	port def engineActivationIPT { flow in onOffSecure }
	 port def alertPortIPT { flow in criticalAlert } 
	 port def alertPortOPT { flow out criticalAlert } port def motorTempIPT { flow in celciusTemp } port def fuelLitersIPT { flow in liters } port def engineAtivationOPT { flow out onOffSecure } port def bateryLevelIPT { flow in percent } port def dataPortIOPT { flow inout byteStream }  port def noSignalAlertIPT { flow in noSignalAlert } port def noSignalAlertOPT { flow out noSignalAlert } 
	 port def displayPort { ports : 
	 	litersAlert : alertPortIPT ; 
	 	temmpAlert : alertPortIPT ;
	 	tempStatusCPT: motorTempIPT;
	 	bateryStatus: bateryLevelIPT;
	 	fuelStatus: fuelLitersIPT;
	 	motorSignal: noSignalAlertIPT;
	 	fuelSignal: noSignalAlertIPT;
	 	baterySignal: noSignalAlertIPT;
	 }  
	 port def firmwareUpdatePortIPT { flow in byteStream } connector def connectTemperature { participants : ~ ^out : mortorTempOPT ; ~ ^in : motorTempIPT ; } connector def connectAlerts { participants : ~ ^in : alertPortIPT ; ~ ^out : alertPortOPT ; } connector def conectLiters { participants : ~ ^out : fuelLitersOPT ; ~ ^in : fuelLitersIPT ; } connector def porcentConnect { participants : ~ ^out : bateryLevelOPT ; ~ ^in : bateryLevelIPT ; } connector def actvationConector { participants : ~ ^out : engineAtivationOPT ; ~ ^in : engineActivationIPT ; } connector def noSignalConector { participants : ~ ^out : noSignalAlertOPT ; ~ ^in : noSignalAlertIPT ; } 
 }
 package scComponents { 
	import SysADL.types ;  import scPorts ;
	component def displayControllerCP { ports :  p2 : firmwareUpdatePortIPT ;  p0 : displayPort [ 1 , 3 ] ; comunication : dataPortIOPT [ 1 , 5 ] ; configuration { components : baterySensorControlerCP : baterySensorControlerCP { using ports : p2 : alertPortOPT ; p0 : bateryLevelIPT ; p1 : bateryLevelOPT ; p3 : noSignalAlertOPT ; p4 : dataPortIOPT ; } tempSensorControlerCP : tempSensorControlerCP { using ports : p2 : alertPortOPT ; p1 : mortorTempOPT ; p0 : motorTempIPT ; p3 : noSignalAlertOPT ; p4 : dataPortIOPT ; } delegations : p1 to bateryStatus p3 to baterySignal p4 to comunication } }
	component def tempSensorControlerCP { ports : p2 : alertPortOPT [ 1 , 2 ] ; p1 : mortorTempOPT ; p0 : motorTempIPT ; p3 : noSignalAlertOPT ; p4 : dataPortIOPT ; configuration { } }
	component def fuelSensorControlerCP { ports : p2 : alertPortOPT [ 1 , 2 ] ; p1 : fuelLitersOPT ; p0 : fuelLitersIPT ; p3 : noSignalAlertOPT ; p4 : dataPortIOPT ; configuration { } }
	component def baterySensorControlerCP { ports :  p0 : bateryLevelIPT ; p1 : bateryLevelOPT ; p2 : noSignalAlertOPT ; p3 : dataPortIOPT ; configuration { } } boundary
	component def baterySensorBCP { ports : newPort : bateryLevelOPT ; } boundary
	component def fuelSensorBCP { ports : newPort : fuelLitersOPT ; } boundary
	component def engineTempSensorBCP { ports : newPort : mortorTempOPT ; } boundary
	component def beepControllerBCP { ports : newPort : alertPortIPT [ 1 , 1 ] ; }
	component def engineShoutDownCP { 
		ports : tempSensorAlert : alertPortIPT ; fuelSensorAlert : alertPortIPT ; alertOut : alertPortOPT ; shoutDownPort : engineAtivationOPT ; conn : dataPortIOPT ; 
		configuration { 
			
		}
	}
	component def engineCP { 
		ports : p0 : engineActivationIPT [ 2 , 1 ] ; conn : dataPortIOPT ; 
		configuration { 
			components : inginitionCP : inginitionBCP { 
				using ports : p0 : engineAtivationOPT ;
			} engineShoutDownCP : engineShoutDownCP { 
				using ports : tempSensorAlert : alertPortIPT ; fuelSensorAlert : alertPortIPT ; alertOut : alertPortOPT ; shoutDownPort : engineAtivationOPT ;
			} fuelSensorControlerCP : fuelSensorControlerCP { 
				using ports : p2 : alertPortOPT ; p1 : fuelLitersOPT ; p0 : fuelLitersIPT ; p3 : noSignalAlertOPT ; p4 : dataPortIOPT ;
			} tempSensorControlerCP : tempSensorControlerCP { 
				using ports : p2 : alertPortOPT ; p1 : mortorTempOPT ; p0 : motorTempIPT ; p3 : noSignalAlertOPT ; p4 : dataPortIOPT ;
			} connectors : conFuelAlert : connectAlerts 
			bindings p2 = fuelSensorAlert ; delegations : p0 to p0 shoutDownPort to p0
		}
	} boundary
	component def inginitionBCP { 
		ports : p0 : engineAtivationOPT ;  
		
	} 
} 