Model SysADLModel ; 
package SysADL.types { 
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { }
} 
Requirement motorTempSensorFR ( 1.3 ) { 
	text = "O sensor deve monitorar continuamente a temperatura e detectar quando excede 100 graus celsius"
derive sensorPerformanceNFR ; } 
Requirement motorControlFR ( 1 ) { 
	text = "Capacidade de Ligar e Desligar o Motor"
} Requirement fuelSensorFR ( 1.2.1 ) { 
	text = "Monitora a quantidade de combustivel e detecta se está abaixo de 2 litros"
derive sensorPerformanceNFR ; } 
Requirement baterySensorFR ( 2.1 ) { 
	text = "Acompanha a carga da bateria e identifica quando está abaixo de 20%" 
	derive  sensorPerformanceNFR ; } 
Requirement statusDisplayFR ( 2 ) { 
	text = "Avisa visualmente o motorista o estado do sistema e exibe alertas visuais"
} 
Requirement engineActivationDeviceFR ( 1.1 ) { 
	text = "Dispositivo acionado pelo usuário para ligar o motor" 
} 
 
Requirement AutoTurnOffFR ( 1.2 ) { 
	text = "Desligar o motor se uma das condições energenciais do sensor de temperatura ou combustivel forem satisfeitas por 2 minutos continuos"
} 
Requirement beepAlarmFR ( 3 ) { text = "Faz um barulho para alertar o usuário" } 
Requirement sensorPerformanceNFR ( 3.0 ) { 
	text = "Os sensores devem ter uma resposta atualização de estado de no máximo 2 segundos"
} 
Requirement alarmPerformanceNFT ( 3.1 ) { 
	text = "O sistema deve responder com o alarme no máximo em 0.1 segundos após detectar condições críticas" 
	derive beepAlarmFR , statusDisplayFR ;
} 
Requirement compatibilityNFR ( 3.2 ) { 
	text = "O sistema deve ser capaz de ser conectado em diferentes veículos independente do fabricante."
} 
Requirement upgradabilityNFR ( 3.3 ) { 
	text = "O sistema deve ser suportar updates de firmware para possíveis correções no software em casos de necessidade."
} 
Requirement failureDetectionNFT ( 3.4 ) { 
	text = "O sistema deve detectar caso algum sensor ou componente esteja apresentando falhas. E exibir elas ao usuário no status display." 
	derive statusDisplayFR ;
} 
Requirement securityNFR ( 3.5 ) { 
	text = "O sistema deve bloquear acessos indevidos ao sistema e modificações nos componentes dele. Toda a comunicação de não críticos (não provenientes diretamente do sensor) deve ser criptografada."
	derive engineActivationDeviceFR,motorControlFR
; } package dataTypes { 
	import SysADL.types ; 
	value type celciusTemp extends SysADL.types.Real { } 
	value type liters extends SysADL.types.Real { } 
	value type percent extends SysADL.types.Real { }   value type eLiters extends liters { } value type criticalAlert extends SysADL.types.Boolean { } value type noSignalAlert extends SysADL.types.Boolean { } enum onOff { On , Off } datatype onOffData { attributes : ^type : onOff ; } value type encriptationKey { } value type byteStream { } datatype encryptedLiters { attributes : key : encriptationKey ; ^value : eLiters ; } datatype encryptedTemp { } datatype encryptedPorcent { } } package scComponents { import SysADL.types ; import ports ; import scPorts ;
	component def displayControllerCP { ports :  portaAlerta : alertPortIPT ; configuration { } }
	component def tempSensorControlerCP { ports : newPort : alertPortOPT ; }
	component def fuelSensorControlerCP { ports : newPort : alertPortOPT ; }
	component def baterySensorControlerCP { ports : newPort : alertPortOPT ; } boundary
	component def baterySensorCP { ports : newPort : baterySensorOPT ; } boundary
	component def fuelSensorCP { ports : newPort : fuelSensorOPT ; } boundary
	component def engineTempSensorCP { ports : newPort : mortorSensorOPT ; }
	component def beepControllerCP { ports : newPort : alertPortIPT [ 1 , 2 ] ; }
	component def engineShoutDownCP { ports : tempSensorAlert : alertPortIPT ; fuelSensorAlert : alertPortIPT ; alertOut : alertPortOPT ; }
	component def engineCP { ports : newPort : engineActivationIPT ; } boundary
	component def inginitionCP { } } 
	package scPorts { import SysADL.types ; 
		import dataTypes ; 
		port def mortorSensorOPT { flow out celciusTemp } port def fuelSensorOPT { flow out liters } port def baterySensorOPT { flow in percent } port def engineActivationIPT { flow in onOffData }
	 port def alertPortIPT { flow in criticalAlert } port def alertPortOPT { flow out criticalAlert } }